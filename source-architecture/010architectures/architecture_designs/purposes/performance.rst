复杂度来源-高性能
#################

技术发展带来了性能上的提升，不一定带来复杂度的提升::

    例如，硬件存储从纸带→磁带→磁盘→SSD，并没有显著带来系统复杂度的增加。
    因为新技术会逐步淘汰旧技术，这种情况下我们直接用新技术即可，不用担心系统复杂度会随之提升。
    只有那些并不是用来取代旧技术，而是开辟了一个全新领域的技术，才会给软件系统带来复杂度，
      因为软件系统在设计的时候就需要在这些技术之间进行判断选择或者组合。

    就像汽车的发明无法取代火车，飞机的出现也并不能完全取代火车，
      所以我们在出行的时候，需要考虑选择汽车、火车还是飞机，这个选择的过程就比较复杂了，
      要考虑价格、时间、速度、舒适度等各种因素。

软件系统中高性能带来的复杂度主要体现在两方面::

    一方面是单台计算机内部为了高性能带来的复杂度
    另一方面是多台计算机集群为了高性能带来的复杂度

单机复杂度
==========

计算机内部复杂度最关键的地方就是操作系统。计算机性能的发展本质上是由硬件发展驱动的，尤其是 CPU 的性能发展。著名的 “摩尔定律” 表明了 CPU 的处理能力每隔 18 个月就翻一番；而将硬件性能充分发挥出来的关键就是操作系统，所以操作系统本身其实也是跟随硬件的发展而发展的，操作系统是软件系统的运行环境，操作系统的复杂度直接决定了软件系统的复杂度。

.. note:: 操作系统和性能最相关的就是进程和线程。操作系统调度的最小单位就变成了线程，而进程变成了操作系统分配资源的最小单位。

进程间通信方式包括::

    管道、消息队列、信号量、共享存储等

多个 CPU 能够同时执行计算任务，从而实现真正意义上的多任务并行::

    解决方案有 3 种：
    1. SMP（Symmetric Multi-Processor，对称多处理器结构）
    2. NUMA（Non-Uniform Memory Access，非一致存储访问结构）
    3. MPP（Massive Parallel Processing，海量并行处理结构）

.. note:: 如果我们要完成一个高性能的软件系统，需要考虑如多进程、多线程、进程间通信、多线程并发等技术点，而且这些技术并不是最新的就是最好的，也不是非此即彼的选择。在做架构设计的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合，这个过程同样很复杂。举一个最简单的例子：Nginx 可以用多进程也可以用多线程，JBoss 采用的是多线程；Redis 采用的是单进程，Memcache 采用的是多线程，这些系统都实现了高性能，但内部实现差异却很大。

集群的复杂度
============

进入互联网时代后，业务的发展速度远远超过了硬件的发展速度。例如::

    2016 年 “双 11” 支付宝每秒峰值达 12 万笔支付
    2017 年春节微信红包收发红包每秒达到 76 万个

任务分配-


.. image:: /images/architectures/design_performance1.png







